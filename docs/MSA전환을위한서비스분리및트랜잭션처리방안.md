## 주요 기능 및 트랜잭션 범위 분석
- - -
- 현재 서비스 구조는 모놀리식 아키텍처로 구성되어 있고 다음과 같은 주요 기능을 제공
- 이커머스 상품 주문 결제
    ```java
    주문결제_TX() {
        사용자조회();
        결제_가능여부_체크();
        재고_수량_체크/재고_차감();
        사용자_포인트_차감();
        결제처리();
        결제정보_데이터플랫폼_전송();
    }
    ```

  - 사용자조회, 결제 가능여부 및 재고 차감, 포인트 차감과 데이터 플랫폼 전송 로직이 하나의 트랜잭션으로 묶여있음
    - 모든 작업이 하나의 트랜잭션 안에서 이루어져 데드락이나 타임아웃 발생 가능성이 높다.
    - 데이터 플랫폼 전송 실패 시 에러가 발생하지 않도록 따로 로직을 추가해야 한다.
    - 데이터 플랫폼 전송이 오래 걸리면 사용자 요청 응답 시간이 길어져 사용자 경험이 저하될 수 있다.
    - 데이터 플랫폼 전송 로직이 결제 로직과 섞여 있어 관심사가 분리되지 않아 유지보수 및 가독성이 떨어진다.
  - Spring Event를 사용하여 데이터 플랫폼 전송을 비동기로 처리 가능
  
      ```java
      주문결제_TX() {
          사용자조회();
          결제_가능여부_체크();
          재고_수량_체크/재고_차감();
          사용자_포인트_차감();
          결제처리();
          결제_완료_이벤트_발행();
      }
    
      @Async
      @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
      데이터_플랫폼_전송_TX(결제_완료_이벤트 event) {
          데이터_플랫폼_전송();
      }
      ```
    - @Async 어노테이션을 사용하여 비동기로 처리
    - 모놀리식 애플리케이션에서는 Spring Event를 사용하여 해결 가능하지만, MSA 환경에서는 메시지 브로커가 필요
    - 데이터 플랫폼 전송 로직을 분리하여 관심사를 분리할 수 있다 (느슨한 결합)
    - 메인 트랜잭션에서 데이터 플랫폼 전송을 제거하여 사용자 요청에 대한 응답 속도를 개선할 수 있다
    - 이벤트 기반 구조로 변경하여 새로운 기능 추가 시 기존 코드를 수정하지 않고 확장할 수 있다
    - 결제 처리와 데이터 플랫폼 전송을 별도의 트랜잭션으로 분리하여 독립적으로 실패를 처리할 수 있다
- - -
## 서비스 분리 설계 및 트랜잭션 처리
- - -
### 서비스 분리 및 주요 담당 로직
- 상품 서비스 : 상품 정보 조회, 인기 상품 조회
- 결제 서비스 : 결제 원장 생성, 결제 승인/취소 처리
- 주문 서비스 : 주문 정보 생성, 주문 정보 조회, 주문 취소
- 사용자 서비스 : 사용자 정보 조회, 사용자 잔액 충전/차감, 사용자 잔액 조회
- 쿠폰 서비스 : 쿠폰 정보 생성, 쿠폰 발급, 쿠폰 사용

### 이커머스 상품 주문 결제 - 서비스 분리 설계
```java
결제처리_TX() {
    결제_가능여부_체크();
    결제_이력_생성();
}

사용자_잔액차감_TX() {
    사용자_잔액조회();
    사용자_잔액차감();
}

상품_재고차감_TX() {
    상품_재고수량_체크();
    상품_재고차감();
}

결제_상태_변경() {
    결제_상태_변경();
}
```

### MSA 환경(분산 환경)에서 트랜잭션 처리 한계
- 각각의 서비스마다 DB를 가지고 있는 Database Per Service 패턴을 사용하면 각 서비스의 트랜잭션은 서로 다른 데이터베이스에 대해 수행
- 이는 단일 데이터베이스 내에서 이루어지는 로컬 트랜잭션과 달리 ACID 원칙을 보장하기 어려움
  - Atomicity(원자성): 트랜잭션의 모든 작업이 성공하거나 실패해야 한다.
  - Consistency(일관성): 트랜잭션이 완료된 후 데이터베이스는 일관된 상태여야 한다.
  - Isolation(독립성): 트랜잭션은 다른 트랜잭션에 영향을 받지 않아야 한다.
  - Durability(지속성): 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 반영되어야 한다.
- 주문 서비스, 결제 서비스, 유저 서비스가 있을 때
  - 주문 서비스는 상품 주문을 생성
  - 결제 서비스는 상품 주문을 확정 짓고 결제
  - 유저 서비스는 잔액을 차감
  - 각각의 로컬 트랜잭션을 사용하기 때문에 전체 트랜잭션의 일관성을 보장하기 어려움
  - 네트워크 장애, 서비스 중단 등의 문제로 잔액은 차감됐지만 결제에 실패하는 데이터 불일치 문제가 발생 가능

### 해결 방안
##### 1. 2PC (Two-Phase Commit) 패턴
- 2PC (2단계 커밋) 패턴은 분산 트랜잭션을 원자적으로 유지하기 위해 사용되는 기법으로, 데이터베이스 시스템이나 분산 시스템에서 ACID 특성을 보장할 때 활용
- 2PC는 코디네이터와 여러 데이터베이스 간의 합의를 통해 트랜잭션 커밋/롤백이 결정
  - 원자성 보장: 2PC의 핵심은 여러 데이터베이스나 서비스에 걸쳐 있는 트랜잭션도 하나의 트랜잭션처럼 다룰 수 있게 해준다는 것.
    즉, 모든 작업이 성공적으로 수행되거나 아무 작업도 수행되지 않은 것처럼 보장
  - 코디네이터의 중요성: 코디네이터는 분산 트랜잭션을 관리하고 조율하는 중요한 역할을 함.
    모든 작업의 상태를 모니터링하고, 최종 커밋 또는 롤백 결정
- 동작 방식
  - 2PC는 Prepare(준비) 단계와 Commit(커밋) 단계로 나누어 진행
  - 1단계 - Prepare
    - 트랜잭션 코디네이터(TC)가 모든 참여 노드(데이터베이스 또는 마이크로서비스)에게 트랜잭션을 준비할 것을 요청
    - 각 참여 노드는 트랜잭션을 실행할 준비가 되면 예/아니오 응답을 TC에게 보냄
    - 예라고 응답한 노드는 이후 트랜잭션을 롤백할 수 없도록 상태를 고정 (Locking)
  - 2단계 - Commit
    - 모든 노드가 예라고 응답하면 TC는 커밋 명령을 내려 모든 노드가 트랜잭션을 실제로 완료하도록 함
    - 만약 하나라도 아니오라고 응답하면 TC는 롤백 명령을 내려 모든 노드가 트랜잭션을 취소
- 2PC의 장점
  - 일관성(Consistency) 보장
  - 데이터 정합성이 보장되므로 금융 시스템 등 강한 트랜잭션 보장이 필요한 경우 적합
  - ACID 준수를 원하는 데이터베이스 트랜잭션에서 활용 가능
- 2PC의 단점
  - 노드 장애 발생 시 블로킹(Block) 문제 발생
  - 모든 노드의 응답을 기다려야 하기 때문에 일부 노드가 응답하지 않으면 전체 트랜잭션이 멈춤
  - 모든 노드가 준비되기 전까지 커밋을 할 수 없으므로 속도가 느려짐
  - 트랜잭션이 길어질수록 시간이 오래 걸리고, 타임아웃이 발생할 가능성이 높아짐

##### 2. SAGA 패턴
- SAGA 패턴은 마이크로서비스 환경에서 트랜잭션을 관리하기 위한 비동기 이벤트 기반의 분산 트랜잭션 관리 기법
- 각 서비스가 독립적으로 트랜잭션을 실행하고, 실패 시 보상 작업(Compensation)을 수행하는 방식
- 동작 방식
1. Choreography 방식
   - 각 서비스가 다른 서비스의 상태를 이벤트 기반으로 트리거하면서 트랜잭션을 진행
   - 예를 들어, "주문 생성 → 결제 요청 → 배송 요청"이 하나의 SAGA 트랜잭션이라면
     - 주문 서비스가 주문을 생성하고 "주문 생성됨" 이벤트를 발행.
     - 결제 서비스는 이벤트를 받아 결제를 수행한 후 "결제 완료됨" 이벤트를 발행.
     - 배송 서비스는 결제가 완료되었음을 감지하고 배송을 수행.
   - 중간에 실패하면, 보상 트랜잭션(Compensating Transaction)을 실행해 이전 단계를 취소
   - 장점
     - 서비스 간의 결합도가 낮음 (완전한 비동기 방식)
     - 장애 발생 시 특정 서비스만 롤백 가능
   - 단점
     - 트랜잭션 흐름이 복잡해질 수 있음 (서비스 간의 이벤트 의존성 증가)
     - 디버깅이 어려울 수 있음
2. Orchestration 방식
   - SAGA Orchestrator (중앙 컨트롤러) 가 존재하여 각 단계의 트랜잭션을 명시적으로 관리
   - 오케스트레이터는 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시
   - 오케스트레이터는 각 단계의 성공 여부를 모니터링하고, 실패 시 보상 트랜잭션을 발생시켜 롤백을 시도
   - 장점
     - 트랜잭션 흐름이 명확함
     - 중앙에서 관리하기 때문에 복잡성을 줄일 수 있음
   - 단점
     - 중앙 컨트롤러의 단일 장애점(Single Point of Failure, SPOF) 문제
     - 오케스트레이션 서비스가 과부하될 수 있음