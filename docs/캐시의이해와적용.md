## 캐시의 이해와 적용
- - -

### 1. 캐시란?
- 캐시(Cache)는 자주 사용되는 데이터를 미리 저장해 두고 빠르게 제공하는 저장소
- 애플리케이션 성능을 최적화하고 응답 속도를 높이는 데 사용되며, 메모리, 디스크, 네트워크 등 다양한 계층에서 동작
- - -
### 2. 캐시의 주요 개념
#### 1) 캐시 히트와 캐시 미스
- 캐시 히트(Cache Hit)
  - 요청한 데이터가 캐시에 존재하여 빠르게 반환되는 경우
  - 캐시의 효과를 극대화하려면 캐시 히트 비율을 높이는 것이 중요
- 캐시 미스(Cache Miss)
  - 요청한 데이터가 캐시에 없어 원본 데이터 소스에서 가져와햐 하는 경우

#### 2) 캐시 일관성(Cache Consistency)
- 원본 데이터가 변경될 때 캐시도 동기화되어야 함
- TTL 설정, 캐시 무료롸 전략 등을 활용하여 관지

#### 3) 캐시 만료(Cache Expiration)
- 일정 시간이 지나면 캐시를 삭제하여 오래된 데이터를 제거하는 방식
- 일반적으로 TTl 값을 설정하여 자동 만료
- - -

### 3. 캐시의 주요 유형
#### 1) 위치에 따른 캐시 분류
| 캐시 유형 |설명|
|-------|---|
| 클라이언트 캐시(Client-side Cache)  |웹 브라우저, 모바일 앱에서 활용 (예: HTTP 캐시, 쿠키)|
| 서버 캐시(Server-side Cache)  |서버에서 데이터를 캐싱하여 제공 (예: Spring Cache, Redis)|
| CDN 캐시(Content Delivery Network Cache)  |전 세계 엣지 서버에서 정적 콘텐츠 제공 (예: Cloudflare, AWS CloudFront)|
| 데이터베이스 캐시(Database Cache)  |데이터베이스의 쿼리 결과를 캐싱 (예: Redis, MySQL Query Cache)|

#### 2) 사용 목적에 따른 캐시 분류
| 캐시 유형 | 설명 |
|---|---|
|데이터베이스 캐시|DB 조회 결과를 캐싱하여 부하를 줄임 (예: Redis, Memcached)|
|웹 캐시(Web Cache)|HTTP 응답을 캐싱하여 웹사이트 성능을 향상 (예: Nginx, Varnish)|
|파일 시스템 캐시|파일 시스템의 자주 사용되는 데이터를 캐싱 (예: OS의 페이지 캐시)|
|컴파일러 캐시|프로그램 빌드 속도를 높이기 위한 캐시 (예: Maven, Gradle 캐시)|
- - -

### 4. 캐시 전략
#### 1) 캐시 쓰기(Write) 전략
| 전략                      | 설명|
|-------------------------|---|
| Write-through           | 데이터를 캐시에 저장하면서 원본 데이터베이스에도 즉시 저장|
| Write-back (Lazy write) | 	먼저 캐시에 저장한 후 일정 시간 후 DB에 반영|
| Write-around            | 캐시에 저장하지 않고 DB에 직접 저장한 후 필요한 경우 캐시 로드|

#### 2) 캐시 읽기(Read) 전략
| 전략 | 설명|
|---|---|
|Cache-aside (Lazy Loading)	| 데이터를 요청할 때 캐시 확인 후 없으면 DB에서 가져와 캐싱|
|Read-through|캐시에서 데이터를 직접 반환하며, 캐시에 없을 경우 자동으로 DB 조회 후 저장|
|Write-behind|캐시에만 먼저 데이터를 쓰고, 일정 시간이 지난 후 DB에 비동기 저장|

#### 3) 캐시 무효화(Invalidation) 전략
| 전략 | 설명|
|---|---|
|Time-based expiration (TTL)| 일정 시간이 지나면 캐시 삭제|
|Least Recently Used (LRU)|가장 오랫동안 사용되지 않은 데이터 삭제|
|Least Frequently Used (LFU)|가장 적게 사용된 데이터를 삭제|
|Manual Invalidation|특정 조건이 충족되면 수동으로 캐시 삭제|

#### 4) 캐시 로딩(Loading) 전략
| 전략 | 설명|
|---|---|
|Lazy loading| 요청이 발생할 때 데이터를 캐시에 채움 (캐시 미스 발생 가능)|
|Eager loading (Preloading)|미리 데이터를 캐시에 로드하여 미스를 최소화|
- - -

### 5. 캐시 스탬피드(Cache Stampede)
- 캐시 스탬피드란, TTL이 만료된 후 동시에 여러 요청이 원본 데이터베이스로 몰려 과부하가 발생하는 현상

#### 해결 방법
#### 1) 캐시 갱신 분산(Randomized TTL)
- 각 데이터 항복의 TTL을 다르게 설정하여 동시에 캐시가 만료되는 문제 방지
```java
Random random = new Random();
int randomTTL = 300 + random.nextInt(60); // 300초 ± 60초 랜덤 TTL 설정
redisTemplate.opsForValue().set(key, value, Duration.ofSeconds(randomTTL));
```
#### 2) 더블 캐싱(Double Caching)
- 캐시 만료 전에 백그라운드 스레드가 새로운 데이터를 갱신하여 캐시 미스 방지
```java
@Scheduled(fixedRate = 5000) // 5초마다 캐시 갱신
public void refreshCache() {
    String data = fetchDataFromDB();
    cache.put("key", data);
}
```
#### 3) Mutex Lock(캐시 리로드 락)
- 캐시가 만료된 경우 동시에 여러 요청이 DB로 가지 않도록 Lock 사용
```java
synchronized (this) {
    if (cache.get("key") == null) {
        String data = fetchDataFromDB();
        cache.put("key", data);
    }
}
```
#### 4) Soft Expiration(소프트 만료)
- 캐시가 만료되더라도 이전 값을 질정 시간 유지하며 백그라운드에서 데이터 갱신
```java
if (cacheExpired()) {
    return oldData; // 기존 데이터 제공
} else {
    return fetchDataFromDB(); // 백그라운드에서 새 데이터 갱신
}
```
- - -
### 6. Redis-Cli 사용해보기
#### 1) Strings
- Redis의 문자열(Strings) 데이터 타입은 가장 기본적인 데이터 타입으로, 키-값 으로 데이터 저장
- ✅String 저장 및 조회
```bash
127.0.0.1:6379> SET user:1 "seulgi"
OK
127.0.0.1:6379> GET user:1
"seulgi"
```
- ✅String 삭제
```bash
127.0.0.1:6379> SET user:1 "seulgi"
OK
127.0.0.1:6379> GET user:1
"seulgi"

127.0.0.1:6379> DEL user:1
(integer) 1
127.0.0.1:6379> GET user:1
(nil)
```
- ✅String 값 증가 및 감소
```bash
127.0.0.1:6379> SET counter 100
OK

127.0.0.1:6379> INCR counter
(integer) 101

127.0.0.1:6379> DECR counter
(integer) 100

127.0.0.1:6379> INCRBY counter 10
(integer) 110

127.0.0.1:6379> DECRBY counter 5
(integer) 105
```

#### 2) Sets
- Redis의 Sets는 중복을 허용하지 않는 집합을 저장하는 데이터 타입
- ✅ Set 값 추가 및 조회
```bash
127.0.0.1:6379> SADD fruits "apple" "banana" "cherry"
(integer) 3

127.0.0.1:6379> SMEMBERS fruits
1) "banana"
2) "apple"
3) "cherry"
```
- ✅ Set에 중복값 추가 시도
```bash
127.0.0.1:6379> SADD fruits "banana"
(integer) 0  # 중복된 값이라 추가되지 않음
```
- ✅ 특정 값 존재 여부 확인
```bash
127.0.0.1:6379> SISMEMBER fruits "apple"
(integer) 1

127.0.0.1:6379> SISMEMBER fruits "grape"
(integer) 0
```
- ✅ Set에서 특정 값 제거
```bash
127.0.0.1:6379> SREM fruits "cherry"
(integer) 1

127.0.0.1:6379> SMEMBERS fruits
1) "banana"
2) "apple"
```
- ✅ 두 개의 Set 연산
```bash
127.0.0.1:6379> SADD set1 "a" "b" "c"
(integer) 3
127.0.0.1:6379> SADD set2 "b" "c" "d"
(integer) 3

# 교집합 (INTERSECTION)
127.0.0.1:6379> SINTER set1 set2
1) "b"
2) "c"

# 합집합 (UNION)
127.0.0.1:6379> SUNION set1 set2
1) "a"
2) "b"
3) "c"
4) "d"

# 차집합 (DIFFERENCE)
127.0.0.1:6379> SDIFF set1 set2
1) "a"
```

#### 3) Sorted Sets
- Redis의 Sorted Sets(ZSETs)는 점수(Score)를 기반으로 정렬된 데이터 저장을 지원하는 데이터 타입
- ✅ Sorted Set 값 추가 및 조회
```bash
127.0.0.1:6379> ZADD scores 100 "seulgi" 200 "jin" 150 "dongjin" 250 "sengho"
(integer) 4

127.0.0.1:6379> ZRANGE scores 0 -1 WITHSCORES
1) "seulgi"
2) "100"
3) "dongjin"
4) "150"
5) "jin"
6) "200"
7) "sengho"
8) "250"

```
- ✅ 특정 사용자 점수 조회
```bash
127.0.0.1:6379> ZSCORE scores "seulgi"
"100"
```
- ✅ 점수 변경 (증가 / 감소)
```bash
127.0.0.1:6379> ZINCRBY scores 50 "seulgi"
"150"

127.0.0.1:6379> ZRANGE scores 0 -1 WITHSCORES
1) "dongjin"
2) "150"
3) "seulgi"
4) "150"
5) "jin"
6) "200"
7) "sengho"
8) "250"
```
- ✅ 순위 (Rank) 조회
```bash
127.0.0.1:6379> ZRANK scores "seulgi"
(integer) 1  # 낮은 점수일수록 낮은 순위

127.0.0.1:6379> ZREVRANK scores "seulgi"
(integer) 2  # 높은 점수일수록 높은 순위 (내림차순)
```
- ✅ 특정 점수 범위의 데이터 조회
```bash
127.0.0.1:6379> ZRANGEBYSCORE scores 100 220 WITHSCORES
1) "dongjin"
2) "150"
3) "seulgi"
4) "150"
5) "jin"
6) "200"
```
- ✅ 특정 범위 삭제
```bash
127.0.0.1:6379> ZREMRANGEBYSCORE scores 100 150
(integer) 2

127.0.0.1:6379> ZRANGE scores 0 -1 WITHSCORES
1) "jin"
2) "200"
3) "sengho"
4) "250"
```
- - -
### 7. 내 프로젝트에 적용하기
#### 1) 선착순 쿠폰 발급
```java
@DistributedLock
public CouponServiceDto issueCoupon(Long userId, Long couponId) {
    // 1. 쿠폰이 존재하는지 검증
    // 2. 중복 발급 여부 검증
    // 3. 쿠폰 수량 검증
    // 4. 쿠폰 수량 차감 및 db에 수량 업데이트
    // 5. 사용자 보유 쿠폰 테이블에 정보 업데이트
  return CouponServiceDto
}
```
#### 현재 로직의 문제점
1. 모든 로직이 DB 중심이므로 트래픽 증가 시 병목 발생 
   - 쿠폰 존재 여부 조회 → coupon 테이블에 SELECT 쿼리로 couponId 조회
   - 중복 발급 확인 → user_coupon 테이블에 SELECT 쿼리로 couponId 조회
   - 쿠폰 수량 검증 → coupon 테이블에 SELECT 쿼리로 수량 조회
   - 쿠폰 수량 차감 → coupon 테이블에 UPDATE 쿼리로 수량 차감
   - 사용자 보유 쿠폰 테이블 업데이트 → user_coupon 테이블에 INSERT 쿼리로 쿠폰 정보 입력
2. @DistributedLock을 사용한 동시성 제어는 락 경합 유발
    - @DistributedLock을 사용하면 단일 노드에서만 락이 작동할 가능성
    - 분산 환경에서는 락 관리가 어려움
    - 트래픽이 높을 때 성능 저하
3. 쿠폰 발급이 동기적으로 실행되어 성능 저하 
    - DB 조회 → 쿠폰 차감 → INSERT 과정이 한 번의 트랜잭션 내에서 실행됨
    - 동기적 실행 방식 때문에 초당 처리량이 낮아짐
    - 트래픽이 증가할수록 응답 시간 증가
4. 선착순 발급 관리가 어려움
    - 선착순으로 지급하려면 DB에서 ORDER BY LIMIT와 같은 쿼리를 추가로 실행해야함
    - 다수의 사용자가 동시에 요청하면 정확한 순서를 보장하기 어려움

#### Redis를 활용한 개선사항
#### 1. 쿠폰 중복 발급 방지 -> Redis SETNX을 활용
```java
@Service
public class CouponService {
    private final StringRedisTemplate redisTemplate;

    public CouponService(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public boolean checkDuplicateCoupon(Long userId, Long couponId) {
        String key = "coupon:user:" + userId + ":" + couponId;
        Boolean isNew = redisTemplate.opsForValue().setIfAbsent(key, "1", 1, TimeUnit.DAYS);
        return isNew != null && isNew; // true: 최초 요청, false: 중복 요청
    }
}
```
- DB 조회 없이 빠르게 중복 발급 여부 확인
- 대량의 트래픽을 Redis에서 처리

#### 2. 쿠폰 수량 관리 -> Redis DECR을 활용
```java
@Service
public class CouponInventoryService {
    private final StringRedisTemplate redisTemplate;

    public CouponInventoryService(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public boolean decreaseCouponStock(Long couponId) {
        String key = "coupon:stock:" + couponId;
        Long stock = redisTemplate.opsForValue().decrement(key);

        if (stock == null || stock < 0) {
            // 재고가 부족한 경우 롤백
            redisTemplate.opsForValue().increment(key);
            return false;
        }
        return true;
    }
}
```
- DB SELECT 조회 없이 빠르게 수량 차감 가능
- 동시에 많은 요청이 와도 원자적 연산이므로 안전
- DB 부하 감소 & 빠른 응답 속도

#### 3. 쿠폰 선착순 발급 -> Redis Sorted Set 활용
```java
// 선착순 큐 관리
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.time.Instant;

@Service
public class CouponQueueService {
    private final StringRedisTemplate redisTemplate;
    private static final int COUPON_LIMIT = 100; // 최대 쿠폰 수량

    public CouponQueueService(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public boolean addToQueue(Long userId, Long couponId) {
        String queueKey = "coupon:queue:" + couponId;
        double timestamp = Instant.now().toEpochMilli(); // 현재 시간을 점수로 사용

        // 유저를 Sorted Set에 추가 (ZADD)
        redisTemplate.opsForZSet().add(queueKey, userId.toString(), timestamp);

        // 현재 큐 크기 확인
        Long queueSize = redisTemplate.opsForZSet().zCard(queueKey);

        // 쿠폰 수량을 초과하면 자동으로 실패 처리
        return queueSize != null && queueSize <= COUPON_LIMIT;
    }

    public boolean checkUserInQueue(Long userId, Long couponId) {
        String queueKey = "coupon:queue:" + couponId;
        Long rank = redisTemplate.opsForZSet().rank(queueKey, userId.toString());
        return rank != null && rank < COUPON_LIMIT;
    }
}
```
- ZADD를 사용하여 유저를 시간 기반으로 정렬하여 저장
- ZCARD를 사용하여 발급 수량을 초과하면 자동으로 실패
- ZRANK를 사용하여 사용자가 선착순 범위 내에 있는지 빠르게 확인

#### 4. 개선된 로직
```java
@Service
public class FirstComeFirstServedCouponService {
    private final CouponQueueService queueService;
    private final CouponService couponService;
    private final CouponInventoryService inventoryService;
    private final DistributedLockService lockService;

    public FirstComeFirstServedCouponService(
            CouponQueueService queueService,
            CouponService couponService,
            CouponInventoryService inventoryService,
            DistributedLockService lockService) {
        this.queueService = queueService;
        this.couponService = couponService;
        this.inventoryService = inventoryService;
        this.lockService = lockService;
    }

    public String issueCoupon(Long userId, Long couponId) {
        // 1️⃣ 선착순 큐에 추가 (Sorted Set 사용)
        boolean isEligible = queueService.addToQueue(userId, couponId);
        if (!isEligible) {
            return "선착순 쿠폰 마감되었습니다.";
        }

        // 2️⃣ 중복 발급 방지 (Redis SETNX)
        if (!couponService.checkDuplicateCoupon(userId, couponId)) {
            return "이미 발급된 쿠폰입니다.";
        }

        // 3️⃣ 쿠폰 재고 차감 (Redis DECR)
        if (!inventoryService.decreaseCouponStock(couponId)) {
            return "쿠폰 재고가 없습니다.";
        }

        // 4️⃣ 분산 락 적용 (Redisson)
        if (!lockService.acquireLock(couponId)) {
            return "쿠폰 발급 요청이 너무 많습니다. 잠시 후 다시 시도하세요.";
        }

        try {
            // 5️⃣ 최종적으로 DB에 반영
            saveCouponToDB(userId, couponId);
        } finally {
            lockService.releaseLock(couponId);
        }

        return "선착순 쿠폰 발급 성공!";
    }
}
```

#### 2) 인기 상품 조회
```java
// 상품서비스
public List<SalesHistoryServiceDto> getBest10Goods() {
    // 1. 시작날짜, 종료날짜 설정
    // 2. DB에 설정한 날짜 범위에서 판매량 순위를 가져옴
}
```

```java
// jpa 쿼리
@Query("""
        SELECT s.goodsId AS goodsId,
               SUM(s.quantity) AS totalQuantity
        FROM SalesHistoryEntity s
        WHERE s.createdAt BETWEEN :startDate AND :endDate
        GROUP BY s.goodsId
        ORDER BY SUM(s.quantity) DESC
        """)
List<SalesHistoryEntity> findTop10GoodsSales(
        @Param("startDate") LocalDateTime startDate,
        @Param("endDate") LocalDateTime endDate,
        Pageable pageable
);
```
#### 현재 로직의 문제점
1. 데이터 조회 부하가 큼
    - WHERE createdAt BETWEEN ... 조건이 포함되어 있으므로 매번 전체 스캔(Full Scan) 가능성 높음
    - 데이터가 많아질수록 DB 부하가 급격히 증가
2. 실시간 성능 문제
    - 집계 연산 (SUM)과 그룹화 (GROUP BY)를 실시간으로 수행
    - ORDER BY SUM(quantity) DESC 수행 시 정렬 비용 증가
    - 대량의 데이터가 쌓일 경우 쿼리 실행 시간이 길어지고 응답 지연 발생
3. 자주 조회되는 데이터지만 매번 재계산
    - 매번 SELECT를 실행하므로 불필요한 DB 부하 발생
    - 캐싱을 적용하지 않으면 동일한 연산을 반복 수행하게 됨

#### Redis를 활용한 개선 사항
#### 1. 판매 이력을 주기적으로 Redis에 반영(Batch 처리)
```java
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

@Service
public class SalesRankingBatchService {
    private final SalesRepository salesRepository;
    private final SalesRankingService rankingService;

    public SalesRankingBatchService(SalesRepository salesRepository, SalesRankingService rankingService) {
        this.salesRepository = salesRepository;
        this.rankingService = rankingService;
    }

    // 매일 자정에 Redis에 상위 판매 상품을 갱신
    @Scheduled(cron = "0 0 0 * * ?") 
    public void updateSalesRanking() {
        LocalDateTime startDate = LocalDateTime.now().minusDays(3);
        LocalDateTime endDate = LocalDateTime.now();

        List<SalesHistoryEntity> topSales = salesRepository.findTop10GoodsSales(startDate, endDate);

        for (SalesHistoryEntity sale : topSales) {
            rankingService.increaseSales(sale.getGoodsId(), sale.getTotalQuantity());
        }
    }
}
```
- 매번 쿼리를 실행하지 않고 일정 주기로만 DB에서 조회
- 실시간 업데이트와 배치를 혼합하여 최적화 가능

#### 2. TTL을 활용한 자동 갱신
```java
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.concurrent.TimeUnit;

@Service
public class CachedSalesRankingService {
    private final StringRedisTemplate redisTemplate;
    private final SalesRankingService rankingService;

    public CachedSalesRankingService(StringRedisTemplate redisTemplate, SalesRankingService rankingService) {
        this.redisTemplate = redisTemplate;
        this.rankingService = rankingService;
    }

    public List<String> getCachedTop10Goods() {
        String cacheKey = "sales:ranking:top10";
        List<String> cachedTop10 = redisTemplate.opsForList().range(cacheKey, 0, -1);

        if (cachedTop10 == null || cachedTop10.isEmpty()) {
            // Redis에 데이터가 없으면, 새로운 랭킹 가져와서 캐싱
            List<String> top10 = rankingService.getTop10Goods();
            redisTemplate.opsForList().rightPushAll(cacheKey, top10.toArray(new String[0]));
            redisTemplate.expire(cacheKey, 1, TimeUnit.HOURS); // 1시간 캐싱
            return top10;
        }
        return cachedTop10;
    }
}
```
- DB에서 직접 조회하는 대신 Redis에서 캐싱된 데이터를 빠르게 반환
- TTL 설정으로 자동 갱신